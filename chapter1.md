## 汇编（nasm/masm）

#### 16位通用寄存器
+ AX
+ BX
+ CX
+ DX
+ SI
+ DI
+ BP
+ SP

其中前4个可以当做8位寄存器:
+ AH
+ AL
+ BH
+ BL
+ CH
+ CL
+ DH
+ DL

#### div指令

1. 除数：有8位和16位两种，在一个reg或内存单元中。
2. 被除数：默认在ax或dx和ax中，如果除数为8位，则被除数为16位，默认在ax中存放；如果除数为16位，被除数就是32位，在dx和ax中存放，dx存放高16位，ax存放低16位。
3. 结果：如果除数为8位，则al存储除法操作的商，ah存储除法操作的玉树余数；如果除数为16位，则ax存储除法操作的商，dx存储除法操作的余数。
4. 格式如下：

   ```
   div reg
   div 内存单元
   div byte ptr ds:[0]
   含义：(al)=(ax)/(ds_16+0)的商
   (ah)=(ax)/(ds_16+0)的余数
   ```


#### xor指令

1. 异或命令。
2. 1 xor 1 = 0
3. 1 xor 0 = 1
4. 0 xor 0 = 0
5. 0 xor 1 = 1

#### in/out端口和读写指令

1. 端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的。比如0x00000~0xE0000是真实的物理内存，而0xE0001~0xFFFFF是从IO接口映射过来的，当访问这部分地址的时，实际上实在访问IO接口
2. 而在另一些计算机系统中，端口是独立编址的，不和内存地址空间发生关系。在这种计算机中，处理器的地址线即连接内存，也连接每个IO接口。在这种处理器中有一个引脚用来区分是内存还是IO接口，当处理器访问内存时，会让这个引脚为高电平，然后与内存相关的电路就会打；相反，如果处理器访问IO端口，那个会让这个引脚为低电平，内存电路被禁止
   如： 0x0001,0x0002,0x0003,.....每个IO接口都会分配若干端口。

3. 在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。

4. 例如：

   ```
   mov dx, 3f8h
   in al, dx ;al用来存放要读入的数据。
   out dx, al;al用来存放要发送到端口的数据
   ```


#### 程序分段

1. `section 段名称`
2. intel处理器要求段在内存中的其实起始物理地址是16字节对齐的。
3. 汇编语言中定义的各个段，也有对齐的要求。具体做法是，在段定义中使用`align=字句，用于指定某个section的汇编地址对齐方式。比如说align=16就表示段是16字节对齐的。`
4. ```
   section data1 align=16
   db 0x55
   section data2 align=16
   db 0x66
   section data3 align=16
   db 0x77
   ```

5. 理论上，如果不考虑段的对齐方式，那么段data1的汇编地址是0, 段data2的汇编地址是1,段data3的汇编地址是2。但是，在这里的段 定义都包含了align=16的对齐字句，情况就不同了。将上面的代码编译 后如下：

6. 5500 0000 0000 0000 0000 0000 0000 0000
   6600 0000 0000 0000 0000 0000 0000 0000
   77

7. 应为段data1之前没有任何内容，故段data1的起始汇编地址是0,
   而0本身是能被16字节对齐的符合align的要求，段的汇编地址其实就是段内第一个元素（数据或指令）的汇编地址。

8. 每个段都有一个汇编地址，为了获得段的汇编地址，nasm编译器提供以下表达式可以用在程序中`section.段名.start`

9. 尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是相对与整个程序的开头来计算的，而不是相对于段的起始地址。
   可以使用vstart字句解决这个问题。如下代码

   ```
   section data1 align=16
   p1: mov ax,1
   section data2 align=16
   p2: mov ax,2
   section data3 align=16
   p3: mov ax,3

   dw p1
   dw p2
   dw p3
   ```

   编译上述代码后
   b801 0000 0000 0000 0000 0000 0000 0000

   b802 0000 0000 0000 0000 0000 0000 0000

   b803 0000 0010 0020 00

   可以看到p1的汇编地址是0x0000，p2的汇编地址是0x0010,
   p3的汇编指地址是0x0020。都是相对于真个程序的起始位置来计算汇编地址的

10. 添加vstart字句后

    ```
    section data1 align=16 vstart=0
    p1: mov ax,1
    section data2 align=16 vstart=0
    p2: mov ax,2
    section data3 align=16 vstart=0
    p3: mov ax,3
    dw p1
    dw p2
    dw p3
    dw section.p2.start
    ```

    编译后

    b801 0000 0000 0000 0000 0000 0000 0000

    b802 0000 0000 0000 0000 0000 0000 0000

    b803 0000 0000 0000 0010 00

    可以看到p1,p2,p3的汇编指令都为0了，也就是说都是相对于段的汇编地址来计算段内指令的汇编地址的，但是段的汇编地址还是0x1000，没有受到影响，段的汇编地址只会受到align的影响

11. 可以使用**dw 标号**，来做实验，查看标号所在的汇编地


#### jmp指令

1. **相对**短转移
   相对短转移的机器操作码为0xEB，操作数是相对于目标地址的偏移量，仅有1字节，有符号数-128~127间。**它的汇编指令的操作数只能是标号和数值，相对短转移指令必须使用**`shrot`**`关键字`**`。例如：`
   `jmp short infinite`
   编译阶段编译器会计算偏移量，计算过程为：编译器用目标位置的汇编地址减去当前指令的汇编地址，再减去当前指令的长度2，保留1字节的结果，作为机器指令的操作数。
   汇编指令中的操作数（数值\/标号）都被编译器用来计算一个8位的偏移量。
   在指令执行时，处理器把指令中的操作数加2，在加到寄存器IP上。
2. 16位**相对**近转移
   和相对短转移类似它操作数同样是相对于目标地址的偏移量，只是转移的范围稍大一些。它的机器操作码为0XE9，该指令长度为3字节。它的汇编指令的操作数同样必须为数值和标号。
   16位相对近转移指令应当使用关键字`near，比如`

   ```
   jmp near infinite
   jmp near 0x3000
   ```

   near关键子可以省略，若没有指定short或near，编译器默认是near

3. 16位间接**绝对**近转移
   这种转移方式也是近转移，即只在段内转移。但是，转移到的目标地址不是在指令中直接给出的，而是用一个**16位的通用寄存器或者内存地址**来间接给出的。比如

   ```
   jmp near bx
   jmp near cx
   jmp near [bx+si]
   jmp [jump_dest]

   jump_deat dw 0xc000
   near关键字可以省略
   ```

4. 16位直接绝对远转移

   例如：
   `jmp 0x0000:0x7c00
   在这里，0X0000和0X7C00分别是段地址和段内偏移地址。执行这条指令之后，处理器用指令中给出的段地址替代段寄存器cs，用给出的偏移地址替换IP，从而跳转到另一个不同的代码段中，即段间转移。`

5. 16位间接绝对地址远转移
   远转移的目标地址也可以通过访问内存或寄存器来间接得到。需要使用   关键字`far。例如`

   ```
   jmp_far dw 0x33c0,0xf00
   jmp far [jump_far]
   jmp far [bx]
   jmp far [bx+si]
   ```

   处理器执行这条指令后，访问段寄存器DS所指向的数据段，从该指令中给出的偏移地址处取出两个字，分别用来代替段寄存器CS和指令指针寄存器IP


#### call指令

与jmp指令类似，只是call指令会把当前的ip的入栈。

1. 16位相对近调用

   ```
   call near proc_1
   call proc_1
   near关键字可以省略
   ```

2. 16位间接绝对近调用

   ```
   call cx
   call [0x3000]
   ```

3. 16位直接绝对远调用

   ```
   call 0x2000:0x0030
   ```

4. 16位间接绝对远调用

   ```
   call far [0x2000]
   call far [proc_1]
   call far [bx]
   必须使用far关键字，否则就变成近调用了。
   ```

5. 远调用需要配合retf来返回




