## 汇编（nasm\/masm）

#### div指令

1. 除数：有8位和16位两种，在一个reg或内存单元中。
2. 被除数：默认在ax或dx和ax中，如果除数为8位，则被除数为16位，默认在ax中存放；如果除数为16位，被除数就是32位，在dx和ax中存放，dx存放高16位，ax存放低16位。
3. 结果：如果除数为8位，则al存储除法操作的商，ah存储除法操作的玉树余数；如果除数为16位，则ax存储除法操作的商，dx存储除法操作的余数。
4. 格式如下：

  ```
  div reg
  div 内存单元
  div byte ptr ds:[0]
  含义：(al)=(ax)/(ds_16+0)的商
  (ah)=(ax)/(ds_16+0)的余数
  ```


#### xor指令

1. 异或命令。
2. 1 xor 1 = 0
3. 1 xor 0 = 1
4. 0 xor 0 = 0
5. 0 xor 1 = 1

#### in\/out端口和读写指令

1. 端口在不同的计算机系统中有着不同的实现方式。在一些计算机系统中，端口号是映射到内存地址空间的。比如0x00000~0xE0000是真实的物理内存，而0xE0001~0xFFFFF是从IO接口映射过来的，当访问这部分地址的时，实际上实在访问IO接口
2. 而在另一些计算机系统中，端口是独立编址的，不和内存地址空间发生关系。在这种计算机中，处理器的地址线即连接内存，也连接每个IO接口。在这种处理器中有一个引脚用来区分是内存还是IO接口，当处理器访问内存时，会让这个引脚为高电平，然后与内存相关的电路就会打；相反，如果处理器访问IO端口，那个会让这个引脚为低电平，内存电路被禁止
  如： 0x0001,0x0002,0x0003,.....每个IO接口都会分配若干端口。

3. 在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。

4. 例如：

  ```
  mov dx, 3f8h
  in al, dx ;al用来存放要读入的数据。
  out dx, al;al用开存放要发送到端口的数据
  ```


#### 程序分段

1. `section 段名称`
2. intel处理器要求段在内存中的其实起始物理地址是16字节对齐的。
3. 汇编语言中定义的各个段，也有对齐的要求。具体做法是，在段定义中使用`align=`字句，用于指定某个section的汇编地址对齐方式。比如说`align=16`就表示段是16字节对齐的。
4. ```
  section data1 align=16
  db 0x55
  section data2 align=16
  db 0x66
  section data3 align=16
  db 0x77
  ```

5. 理论上，如果不考虑段的对齐方式，那么段data1的汇编地址是0, 段data2的汇编地址是1,段data3的汇编地址是2。但是，在这里的段 定义都包含了align=16的对齐字句，情况就不同了。将上面的代码编译 后如下：

6. 5500 0000 0000 0000 0000 0000 0000 0000
  6600 0000 0000 0000 0000 0000 0000 0000
  77

7. 应为段data1之前没有任何内容，故段data1的起始汇编地址是0,
  而0本身是能被16字节对齐的符合align的要求，段的汇编地址其实就是段内第一个元素（数据或指令）的汇编地址。

8. 每个段都有一个汇编地址，为了获得段的汇编地址，nasm编译器提供以下表达式可以用在程序中`section.段名.start`

9. 尽管定义了段，但是，引用某个标号时，该标号处的汇编地址依然是相对与整个程序的开头来计算的，而不是相对于段的起始地址。
  可以使用vstart字句解决这个问题。如下代码

  ```
  section data1 align=16
  p1: mov ax,1
  section data2 align=16
  p2: mov ax,2
  section data3 align=16
  p3: mov ax,3

  dw p1
  dw p2
  dw p3
  ```

  编译上述代码后
  b801 0000 0000 0000 0000 0000 0000 0000

  b802 0000 0000 0000 0000 0000 0000 0000

  b803 0000 0010 0020 00

  可以看到p1的汇编地址是0x0000，p2的汇编地址是0x0010,
  p3的汇编指地址是0x0020。都是相对于真个程序的起始位置来计算汇编地址的

10. 添加vstart字句后

  ```
  section data1 align=16 vstart=0
  p1: mov ax,1
  section data2 align=16 vstart=0
  p2: mov ax,2
  section data3 align=16 vstart=0
  p3: mov ax,3
  dw p1
  dw p2
  dw p3
  dw section.p2.start
  ```

  编译后

  b801 0000 0000 0000 0000 0000 0000 0000

  b802 0000 0000 0000 0000 0000 0000 0000

  b803 0000 0000 0000 0010 00

  可以看到p1,p2,p3的汇编指令都为0了，也就是说都是相对于段的汇编地址来计算段内指令的汇编地址的，但是段的汇编地址还是0x1000，没有受到影响，段的汇编地址只会受到align的影响

11. 可以使用**dw 标号**，来做实验，查看标号所在的汇编地


